// src/app/pages/process/process.component.ts
import { Component, OnInit, OnDestroy } from "@angular/core";
import { FormBuilder, FormGroup, Validators } from "@angular/forms";
import { Subscription, of } from "rxjs";
import { NbThemeService } from "@nebular/theme";
import { catchError, map, tap } from "rxjs/operators";
import {
  ApiService,
  AggregatedProcessData,
  ProcessData,
  DateTimeRange,
} from "../../services/monitoring.service";
import {
  RealtimeService,
  RealtimeConnectionStatus,
} from "../../services/realtime.service";
import { EchartsOption } from "echarts";

@Component({
  selector: "ngx-process",
  templateUrl: "./process.component.html",
  styleUrls: ["./process.component.scss"],
})
export class ProcessComponent implements OnInit, OnDestroy {
  // Subscriptions management
  private themeSubscription: Subscription;
  private dataSubscriptions: Subscription[] = [];
  private colors: any;
  private echartTheme: any;

  // Connection status
  connectionStatus: RealtimeConnectionStatus = RealtimeConnectionStatus.DISCONNECTED;
  lastUpdateTime = new Date();

  // Process data
  activeProcesses: ProcessData[] = [];
  processes: ProcessData[] = [];
  historicalProcesses: AggregatedProcessData[] = [];  // Updated type
  processSummary: any[] = [];

  // Track selected processes
  selectedProcesses: ProcessData[] = [];

  // Charts
  topCpuChartOption: any = {};
  topMemChartOption: any = {};
  processCpuChartOption: any = {};
  processMemChartOption: any = {};
  processCpuHeatmapOption: any = {};
  processMemHeatmapOption: any = {};
  
  // Form controls
  filterForm: FormGroup;
  loading = false;
  processListLoading = false;

  // Error handling
  errorMessage: string = '';
  hasError: boolean = false;


  constructor(
    private theme: NbThemeService,
    private monitoringService: ApiService,
    private realtimeService: RealtimeService,
    private fb: FormBuilder
  ) {
    this.initializeForm();
  }

  ngOnInit() {
    // Subscribe to theme changes for chart styling
    this.themeSubscription = this.theme.getJsTheme().subscribe((config) => {
      this.colors = config.variables;
      this.echartTheme = config.name;
      this.initializeCharts();
    });

    // Start realtime monitoring
    this.startRealtimeMonitoring();

    // Load initial process list for the dropdown
    this.loadProcessList();
  }

  ngOnDestroy() {
    // Clean up all subscriptions
    this.themeSubscription?.unsubscribe();
    this.dataSubscriptions.forEach((sub) => sub.unsubscribe());
    this.dataSubscriptions = [];

    // Stop realtime monitoring
    this.stopRealtimeMonitoring();
  }



  /**
   * Initialize form with proper validation and default values
   */
  private initializeForm(): void {
    const now = new Date();
    const yesterday = new Date();
    yesterday.setDate(yesterday.getDate() - 1);

    this.filterForm = this.fb.group({
      startDate: [this.formatDateForInput(yesterday), [Validators.required]],
      startTime: ['00:00', [Validators.required]],
      endDate: [this.formatDateForInput(now), [Validators.required]],
      endTime: ['23:59', [Validators.required]],
    });

    // Subscribe to form changes for validation feedback
    this.filterForm.valueChanges.subscribe(() => {
      this.hasError = false;
      this.errorMessage = '';
    });
  }

  // // getThemeColors remains the same
  // private getThemeColors(): any {
  //   if (!this.theme) {
  //     return {
  //       primary: "#3366ff",
  //       success: "#00d68f",
  //       info: "#0095ff",
  //       warning: "#ffaa00",
  //       danger: "#ff3d71",
  //       textColor: "#2a2a2a",
  //       backgroundColor: "#ffffff",
  //       borderColor: "#e0e0e0",
  //     };
  //   }
  //   const colors = this.theme.variables;
  //   return {
  //     primary: colors.colorPrimary || colors.primary || "#3366ff",
  //     success: colors.colorSuccess || colors.success || "#00d68f",
  //     info: colors.colorInfo || colors.info || "#0095ff",
  //     warning: colors.colorWarning || colors.warning || "#ffaa00",
  //     danger: colors.colorDanger || colors.danger || "#ff3d71",
  //     textColor: colors.textBasicColor || colors.fgText || "#2a2a2a",
  //     backgroundColor: colors.cardBackgroundColor || colors.bg || "#ffffff",
  //     borderColor: colors.borderBasicColor || colors.separator || "#e0e0e0",
  //   };
  // }

  /**
   * Initialize chart options with theme-specific settings
   */
  private initializeCharts() {
    const baseOption = {
      backgroundColor: this.echartTheme === "transparent" ? this.colors.bg2 : this.colors.white,
      tooltip: {
        trigger: "axis",
        axisPointer: { type: "shadow" },
      },
      grid: { left: "3%", right: "4%", bottom: "3%", containLabel: true },
      legend: {
        textStyle: {
          color: this.colors.fgText,
        },
        formatter: (name) => {
          // Truncate long process names for legend
          return name.length > 20 ? name.substring(0, 17) + '...' : name;
        }
      },
    };

    // Top CPU Consumers Chart
    this.topCpuChartOption = {
      ...baseOption,
      tooltip: {
        trigger: "axis",
        formatter: "{b}: {c}%",
      },
      xAxis: {
        type: "category",
        data: [],
        axisLabel: {
          color: this.colors.fgText,
          rotate: 45,
          interval: 0,
          formatter: (value) => {
            return value.length > 15 ? value.substring(0, 12) + '...' : value;
          }
        },
      },
      yAxis: {
        type: "value",
        name: "CPU %",
        nameTextStyle: { color: this.colors.fgText },
        axisLabel: { color: this.colors.fgText },
        splitLine: { lineStyle: { color: this.colors.separator } },
      },
      series: [{
        name: "CPU Usage",
        type: "bar",
        data: [],
        itemStyle: { color: this.colors.danger },
      }],
    };

    // Top Memory Consumers Chart
    this.topMemChartOption = {
      ...baseOption,
      tooltip: {
        trigger: "axis",
        formatter: "{b}: {c}%",
      },
      xAxis: {
        type: "category",
        data: [],
        axisLabel: {
          color: this.colors.fgText,
          rotate: 45,
          interval: 0,
          formatter: (value) => {
            return value.length > 15 ? value.substring(0, 12) + '...' : value;
          }
        },
      },
      yAxis: {
        type: "value",
        name: "Memory %",
        nameTextStyle: { color: this.colors.fgText },
        axisLabel: { color: this.colors.fgText },
        splitLine: { lineStyle: { color: this.colors.separator } },
      },
      series: [{
        name: "Memory Usage",
        type: "bar",
        data: [],
        itemStyle: { color: this.colors.success },
      }],
    };

    // // Process CPU History Chart
    // this.processCpuChartOption = {
    //   ...baseOption,
    //   tooltip: {
    //     trigger: "axis",
    //     formatter: (params) => {
    //       const date = new Date(params[0].value[0]);
    //       let result = `<b>${date.toLocaleString()}</b><br>`;
    //       params.forEach(p => {
    //         result += `${p.seriesName}: <b>${p.value[1].toFixed(1)}%</b><br>`;
    //       });
    //       return result;
    //     }
    //   },
    //   xAxis: {
    //     type: "time",
    //     axisLabel: {
    //       color: this.colors.fgText,
    //       formatter: "{HH}:{mm}:{ss}",
    //     },
    //   },
    //   yAxis: {
    //     type: "value",
    //     name: "CPU %",
    //     nameTextStyle: { color: this.colors.fgText },
    //     axisLabel: { color: this.colors.fgText },
    //     splitLine: { lineStyle: { color: this.colors.separator } },
    //   },
    //   dataZoom: [{
    //     type: 'inside',
    //     start: 0,
    //     end: 100,
    //     filterMode: 'none'
    //   }, {
    //     type: 'slider',
    //     bottom: 10,
    //     height: 20,
    //     textStyle: { color: this.colors.fgText }
    //   }],
    //   legend: {
    //     show: true,
    //     type: 'scroll',
    //     // bottom: 0,
    //     textStyle: { color: this.colors.fgText },
    //     pageTextStyle: { color: this.colors.fgText }
    //   }
    // };

    // // Process Memory History Chart
    // this.processMemChartOption = {
    //   ...baseOption,
    //   tooltip: {
    //     trigger: "axis",
    //     formatter: (params) => {
    //       const date = new Date(params[0].value[0]);
    //       let result = `<b>${date.toLocaleString()}</b><br>`;
    //       params.forEach(p => {
    //         result += `${p.seriesName}: <b>${p.value[1].toFixed(1)}%</b><br>`;
    //       });
    //       return result;
    //     }
    //   },
    //   xAxis: {
    //     type: "time",
    //     axisLabel: {
    //       color: this.colors.fgText,
    //       formatter: "{HH}:{mm}:{ss}",
    //     },
    //   },
    //   yAxis: {
    //     type: "value",
    //     name: "Memory %",
    //     nameTextStyle: { color: this.colors.fgText },
    //     axisLabel: { color: this.colors.fgText },
    //     splitLine: { lineStyle: { color: this.colors.separator } },
    //   },
    //   dataZoom: [{
    //     type: 'inside',
    //     start: 0,
    //     end: 100,
    //     filterMode: 'none'
    //   }, {
    //     type: 'slider',
    //     bottom: 10,
    //     height: 20,
    //     textStyle: { color: this.colors.fgText }
    //   }],
    //   legend: {
    //     show: true,
    //     type: 'scroll',
    //     // bottom: 0,
    //     textStyle: { color: this.colors.fgText },
    //     pageTextStyle: { color: this.colors.fgText }
    //   }
    // };

    // Process CPU Heatmap
    this.processCpuHeatmapOption = {
      ...baseOption,
      tooltip: {
        position: 'top',
        formatter: (params) => {
          const date = new Date(params.data[0]);
          return `
          <strong>${date.toLocaleString()}</strong><br/>
          Process: ${params.data[1]}<br/>
          CPU: <b>${params.data[2].toFixed(1)}%</b>
        `;
        }
      },
      xAxis: {
        type: 'time',
        axisLabel: {
          color: this.colors.fgText,
          // formatter: (value) => {
          //   const date = new Date(value);
          //   // Show date if range spans multiple days
          //   return date.getHours() === 0 && date.getMinutes() === 0
          //     ? echarts.time.format(date, '{MM}/{dd} {HH}:{mm}', false)
          //     : echarts.time.format(date, '{HH}:{mm}', false);
          // }
        },
      },
      yAxis: {
        type: 'category',
        data: [], // Will be populated with process names
        axisLabel: {
          color: this.colors.fgText,
          interval: 0,
          rotate: 45,
          formatter: (value) => this.truncateCommand(value, 20)
        }
      },
      visualMap: {
        min: 0,
        max: 100,
        calculable: true,
        orient: 'horizontal',
        left: 'center',
        bottom: 10,
        inRange: {
          color: ['#313695', '#4575b4', '#74add1', '#abd9e9', '#e0f3f8', '#ffffbf', '#fee090', '#fdae61', '#f46d43', '#d73027', '#a50026']
        }
      },
      series: [{
        name: 'CPU Usage',
        type: 'heatmap',
        data: [],
        emphasis: {
          itemStyle: {
            shadowBlur: 10,
            shadowColor: 'rgba(0, 0, 0, 0.5)'
          }
        }
      }]
    };

    // Process Memory Heatmap (similar to CPU)
    this.processMemHeatmapOption = {
      ...this.processCpuHeatmapOption,
      name: 'Memory Usage',
      visualMap: {
        ...this.processCpuHeatmapOption.visualMap,
        inRange: {
          color: ['#fff7fb', '#ece7f2', '#d0d1e6', '#a6bddb', '#74a9cf', '#3690c0', '#0570b0', '#045a8d', '#023858']
        }
      }
    };
  }

  /**
   * Start realtime monitoring of processes
   */
  startRealtimeMonitoring() {
    // Connect to WebSocket for process data
    this.realtimeService.connectToMetrics(["process"]);

    // Subscribe to connection status
    this.dataSubscriptions.push(
      this.realtimeService.getConnectionStatus("process").subscribe((status) => {
        this.connectionStatus = status;
      })
    );

    // Subscribe to realtime process data
    this.dataSubscriptions.push(
      this.realtimeService.getRealtimeProcess().subscribe((processData) => {
        if (processData) {
          this.lastUpdateTime = new Date();
          this.updateActiveProcesses(processData);
          this.updateTopProcessCharts();
        }
      })
    );
  }

  /**
   * Stop realtime monitoring
   */
  stopRealtimeMonitoring() {
    this.realtimeService.disconnectAll();
    this.dataSubscriptions.forEach((sub) => sub.unsubscribe());
    this.dataSubscriptions = [];
  }

  /**
   * Load process list for dropdown from active processes
   */
  loadProcessList() {
    this.processListLoading = true;

    // First try to get from current active processes
    if (this.activeProcesses.length > 0) {
      this.processes = [...this.activeProcesses]
        .filter(p => p.pid && p.command && p.command.trim() !== '')
        .sort((a, b) => a.pid - b.pid);
      this.processListLoading = false;
      return;
    }

    // Fallback: get recent historical data to populate process list
    const recentRange = this.monitoringService.getDateRange(0.1); // Last ~2.4 hours

    this.dataSubscriptions.push(
      this.monitoringService.getHistoricalProcesses(recentRange)
        .pipe(
          map(response => response.data || []),
          map(processes => {
            // Get unique processes by PID
            const uniqueProcesses = new Map<number, ProcessData>();
            processes.forEach(p => {
              if (p.pid && p.command && p.command.trim() !== '') {
                // Create new ProcessData object with required properties
                const processData: ProcessData = {
                  pid: p.pid,
                  command: p.command,
                  user: p.user,
                  cpu: 0,    // Default value
                  mem: 0,    // Default value
                  timestamp: p.timestamp
                };
                const existing = uniqueProcesses.get(p.pid);
                if (!existing || new Date(p.timestamp) > new Date(existing.timestamp)) {
                  uniqueProcesses.set(p.pid, processData);
                }
              }
            });
            return Array.from(uniqueProcesses.values()).sort((a, b) => a.pid - b.pid);
          }),
          catchError(error => {
            console.error('Error loading process list:', error);
            this.showError('Failed to load process list');
            return of([]);
          })
        )
        .subscribe(processes => {
          this.processes = processes;
          this.processListLoading = false;
        })
    );
  }

  /**
   * Update active processes list and sort by CPU usage
   */
  updateActiveProcesses(processes: ProcessData | ProcessData[]) {
    if (Array.isArray(processes)) {
      this.activeProcesses = processes
        .filter(p => p && p.pid && p.command && p.command.trim() !== "")
        .sort((a, b) => b.cpu - a.cpu);
    } else {
      const process = processes;
      if (process && process.pid && process.command) {
        const index = this.activeProcesses.findIndex(p => p.pid === process.pid);
        if (index !== -1) {
          this.activeProcesses[index] = process;
        } else {
          this.activeProcesses.push(process);
        }
        this.activeProcesses.sort((a, b) => b.cpu - a.cpu);
      }
    }

    // Update process list if it's empty
    if (this.processes.length === 0 && this.activeProcesses.length > 0) {
      this.processes = [...this.activeProcesses].sort((a, b) => a.pid - b.pid);
    }
  }

  /**
   * Update Top CPU and Memory Consumers charts
   */
  updateTopProcessCharts() {
    if (this.activeProcesses.length === 0) return;

    const topCpuProcesses = [...this.activeProcesses]
      .sort((a, b) => b.cpu - a.cpu)
      .slice(0, 5);

    const topMemProcesses = [...this.activeProcesses]
      .sort((a, b) => b.mem - a.mem)
      .slice(0, 5);

    this.topCpuChartOption = {
      ...this.topCpuChartOption,
      xAxis: {
        ...this.topCpuChartOption.xAxis,
        data: topCpuProcesses.map(p => this.truncateCommand(p.command, 15)),
      },
      series: [{
        ...this.topCpuChartOption.series[0],
        data: topCpuProcesses.map(p => p.cpu),
      }],
    };

    this.topMemChartOption = {
      ...this.topMemChartOption,
      xAxis: {
        ...this.topMemChartOption.xAxis,
        data: topMemProcesses.map(p => this.truncateCommand(p.command, 15)),
      },
      series: [{
        ...this.topMemChartOption.series[0],
        data: topMemProcesses.map(p => p.mem),
      }],
    };
  }

  /**
   * Update Process CPU and Memory history charts for all processes
   */
  // updateProcessCharts() {
  //   if (!this.historicalProcesses || this.historicalProcesses.length === 0) return;

  //   // Clear previous data
  //   this.processCpuChartOption.series = [];
  //   this.processMemChartOption.series = [];

  //   // Prepare colors for each process
  //   const colorPalette = [
  //     this.colors.danger,
  //     this.colors.success,
  //     this.colors.warning,
  //     this.colors.info,
  //     this.colors.primary,
  //     '#5470C6',
  //     '#91CC75',
  //     '#FAC858',
  //     '#EE6666',
  //     '#73C0DE'
  //   ];

  //   // Group data by PID
  //   const dataByPid = new Map<number, AggregatedProcessData[]>();
  //   this.historicalProcesses.forEach(p => {
  //     if (!dataByPid.has(p.pid)) {
  //       dataByPid.set(p.pid, []);
  //     }
  //     dataByPid.get(p.pid).push(p);
  //   });

  //   // Create chart series for each process
  //   let colorIndex = 0;
  //   dataByPid.forEach((processData, pid) => {
  //     // Sort by timestamp
  //     processData.sort((a, b) =>
  //       new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime()
  //     );

  //     // Downsample data to max 500 points - use avg_cpu/avg_mem
  //     const cpuData = this.downsampleLTTB(
  //       processData.map(p => [new Date(p.timestamp).getTime(), p.avg_cpu]),
  //       500
  //     );

  //     const memData = this.downsampleLTTB(
  //       processData.map(p => [new Date(p.timestamp).getTime(), p.avg_mem]),
  //       500
  //     );

  //     const process = processData[0];
  //     const truncatedCommand = this.truncateCommand(process.command, 20);
  //     const color = colorPalette[colorIndex % colorPalette.length];
  //     const lightColor = this.adjustColorOpacity(color, 0.3);

  //     // Add CPU series
  //     this.processCpuChartOption.series.push({
  //       name: `PID ${pid} (${truncatedCommand})`,
  //       type: "line",
  //       symbol: 'none',
  //       sampling: 'lttb',
  //       data: cpuData,
  //       itemStyle: { color },
  //       areaStyle: {
  //         color: {
  //           type: "linear",
  //           x: 0, y: 0, x2: 0, y2: 1,
  //           colorStops: [
  //             { offset: 0, color: lightColor },
  //             { offset: 1, color: this.adjustColorOpacity(color, 0.05) },
  //           ],
  //         },
  //       },
  //     });

  //     // Add Memory series
  //     this.processMemChartOption.series.push({
  //       name: `PID ${pid} (${truncatedCommand})`,
  //       type: "line",
  //       symbol: 'none',
  //       sampling: 'lttb',
  //       data: memData,
  //       itemStyle: { color },
  //       areaStyle: {
  //         color: {
  //           type: "linear",
  //           x: 0, y: 0, x2: 0, y2: 1,
  //           colorStops: [
  //             { offset: 0, color: lightColor },
  //             { offset: 1, color: this.adjustColorOpacity(color, 0.05) },
  //           ],
  //         },
  //       },
  //     });

  //     colorIndex++;
  //   });
  // }

  /**
 * Update Process CPU and Memory heatmaps
 */
updateProcessCharts() {
  if (!this.historicalProcesses || this.historicalProcesses.length === 0) return;

  // Step 1: Filter and aggregate processes intelligently
  const processStats = this.calculateProcessStatistics();
  
  // Step 2: Select top processes based on significance
  const topProcesses = this.selectSignificantProcesses(processStats, 20); // Limit to top 20
  
  // Step 3: Group data by time intervals (5-minute buckets)
  const timeGroupedData = this.groupDataByTimeIntervals(topProcesses, 5);
  
  // Step 4: Build heatmap data
  const { cpuHeatmapData, memHeatmapData, processNames, timeLabels } = 
    this.buildHeatmapData(timeGroupedData);

  // Step 5: Update chart options
  this.updateHeatmapChartOptions(cpuHeatmapData, memHeatmapData, processNames, timeLabels);
}

/**
 * Calculate statistics for each process to determine significance
 */
private calculateProcessStatistics(): Map<string, ProcessStatistics> {
  const processStats = new Map<string, ProcessStatistics>();
  
  this.historicalProcesses.forEach(p => {
    const key = `${p.command}|${p.user}|${p.pid}`;
    
    if (!processStats.has(key)) {
      processStats.set(key, {
        command: p.command,
        user: p.user,
        pid: p.pid,
        totalCpu: 0,
        totalMem: 0,
        maxCpu: 0,
        maxMem: 0,
        count: 0,
        avgCpu: 0,
        avgMem: 0,
        significance: 0
      });
    }
    
    const stats = processStats.get(key);
    stats.totalCpu += p.avg_cpu * p.count;
    stats.totalMem += p.avg_mem * p.count;
    stats.maxCpu = Math.max(stats.maxCpu, p.max_cpu);
    stats.maxMem = Math.max(stats.maxMem, p.max_mem);
    stats.count += p.count;
  });
  
  // Calculate averages and significance scores
  processStats.forEach(stats => {
    stats.avgCpu = stats.count > 0 ? stats.totalCpu / stats.count : 0;
    stats.avgMem = stats.count > 0 ? stats.totalMem / stats.count : 0;
    
    // Significance = weighted combination of avg usage, max usage, and frequency
    stats.significance = (
      stats.avgCpu * 0.4 + 
      stats.maxCpu * 0.3 + 
      stats.avgMem * 0.2 + 
      Math.log(stats.count + 1) * 0.1
    );
  });
  
  return processStats;
}

/**
 * Select most significant processes for visualization
 */
private selectSignificantProcesses(
  processStats: Map<string, ProcessStatistics>, 
  maxCount: number
): ProcessStatistics[] {
  
  return Array.from(processStats.values())
    .filter(stats => 
      stats.avgCpu > 0.1 || // At least 0.1% CPU on average
      stats.maxCpu > 1.0 || // Or peak above 1%
      stats.avgMem > 0.5    // Or significant memory usage
    )
    .sort((a, b) => b.significance - a.significance)
    .slice(0, maxCount);
}

/**
 * Group data by time intervals to reduce noise
 */
private groupDataByTimeIntervals(
  selectedProcesses: ProcessStatistics[], 
  intervalMinutes: number
): Map<string, Map<number, { cpu: number, mem: number, count: number }>> {
  
  const timeGroupedData = new Map<string, Map<number, { cpu: number, mem: number, count: number }>>();
  const intervalMs = intervalMinutes * 60 * 1000;
  
  // Initialize data structure
  selectedProcesses.forEach(process => {
    const key = `${process.command}|${process.user}|${process.pid}`;
    timeGroupedData.set(key, new Map());
  });
  
  // Group historical data by time intervals
  this.historicalProcesses.forEach(p => {
    const processKey = `${p.command}|${p.user}|${p.pid}`;
    
    if (timeGroupedData.has(processKey)) {
      const timestamp = new Date(p.timestamp).getTime();
      const timeSlot = Math.floor(timestamp / intervalMs) * intervalMs;
      
      const processData = timeGroupedData.get(processKey);
      
      if (!processData.has(timeSlot)) {
        processData.set(timeSlot, { cpu: 0, mem: 0, count: 0 });
      }
      
      const slotData = processData.get(timeSlot);
      slotData.cpu += p.avg_cpu * p.count;
      slotData.mem += p.avg_mem * p.count;
      slotData.count += p.count;
    }
  });
  
  // Calculate averages for each time slot
  timeGroupedData.forEach(processData => {
    processData.forEach(slotData => {
      if (slotData.count > 0) {
        slotData.cpu = slotData.cpu / slotData.count;
        slotData.mem = slotData.mem / slotData.count;
      }
    });
  });
  
  return timeGroupedData;
}

/**
 * Build heatmap data arrays
 */
private buildHeatmapData(
  timeGroupedData: Map<string, Map<number, { cpu: number, mem: number, count: number }>>
): {
  cpuHeatmapData: number[][], 
  memHeatmapData: number[][], 
  processNames: string[], 
  timeLabels: number[]
} {
  
  const cpuHeatmapData = [];
  const memHeatmapData = [];
  const processNames = [];
  const timeSet = new Set<number>();
  
  // Collect all unique timestamps
  timeGroupedData.forEach(processData => {
    processData.forEach((_, timestamp) => {
      timeSet.add(timestamp);
    });
  });
  
  const timeLabels = Array.from(timeSet).sort((a, b) => a - b);
  
  // Build process names with better formatting
  timeGroupedData.forEach((processData, key) => {
    const [command, user, pid] = key.split('|');
    const displayName = this.formatProcessDisplayName(command, user, parseInt(pid));
    processNames.push(displayName);
    
    // Create data points for each time slot
    timeLabels.forEach(timestamp => {
      const data = processData.get(timestamp);
      if (data && data.count > 0) {
        cpuHeatmapData.push([timestamp, displayName, Math.round(data.cpu * 10) / 10]);
        memHeatmapData.push([timestamp, displayName, Math.round(data.mem * 10) / 10]);
      } else {
        // Fill missing data with 0
        cpuHeatmapData.push([timestamp, displayName, 0]);
        memHeatmapData.push([timestamp, displayName, 0]);
      }
    });
  });
  
  return { cpuHeatmapData, memHeatmapData, processNames, timeLabels };
}

/**
 * Format process name for better display in heatmap
 */
private formatProcessDisplayName(command: string, user: string, pid: number): string {
  // Extract just the executable name from full path
  const execName = command.split('/').pop() || command;
  
  // Truncate if too long
  const maxLength = 25;
  const truncatedExec = execName.length > maxLength ? 
    execName.substring(0, maxLength - 3) + '...' : execName;
  
  // Show user only if not common system users
  const commonUsers = ['root', 'system', 'daemon'];
  const userPart = commonUsers.includes(user) ? '' : `(${user})`;
  
  return `${truncatedExec}${userPart}`;
}

/**
 * Update heatmap chart options with improved settings
 */
private updateHeatmapChartOptions(
  cpuHeatmapData: number[][], 
  memHeatmapData: number[][], 
  processNames: string[], 
  timeLabels: number[]
): void {
  
  const baseHeatmapOption = {
    backgroundColor: this.echartTheme === "transparent" ? this.colors.bg2 : this.colors.white,
    tooltip: {
      position: 'top',
      formatter: (params) => {
        const date = new Date(params.data[0]);
        const value = params.data[2];
        const metric = params.seriesName.includes('CPU') ? 'CPU' : 'Memory';
        return `
          <div style="text-align: left;">
            <strong>${date.toLocaleString()}</strong><br/>
            <strong>Process:</strong> ${params.data[1]}<br/>
            <strong>${metric}:</strong> <span style="color: ${value > 50 ? '#ff4757' : value > 25 ? '#ffa502' : '#2ed573'}">${value.toFixed(1)}%</span>
          </div>
        `;
      }
    },
    grid: {
      left: '15%',
      right: '10%',
      top: '10%',
      bottom: '15%'
    },
    xAxis: {
      type: 'time',
      axisLabel: {
        color: this.colors.fgText,
        fontSize: 10,
        formatter: (value) => {
          const date = new Date(value);
          const now = new Date();
          const isToday = date.toDateString() === now.toDateString();
          
          if (isToday) {
            return date.toLocaleTimeString('en-US', { 
              hour: '2-digit', 
              minute: '2-digit',
              hour12: false 
            });
          } else {
            return date.toLocaleDateString('en-US', { 
              month: 'short', 
              day: '2-digit',
              hour: '2-digit',
              minute: '2-digit',
              hour12: false
            });
          }
        }
      },
      axisTick: {
        alignWithLabel: true
      },
      splitLine: {
        show: true,
        lineStyle: {
          color: this.colors.separator,
          opacity: 0.3
        }
      }
    },
    yAxis: {
      type: 'category',
      data: processNames,
      axisLabel: {
        color: this.colors.fgText,
        fontSize: 10,
        interval: 0,
        formatter: (value) => {
          return value.length > 20 ? value.substring(0, 17) + '...' : value;
        }
      },
      axisTick: {
        alignWithLabel: true
      },
      splitLine: {
        show: true,
        lineStyle: {
          color: this.colors.separator,
          opacity: 0.3
        }
      }
    }
  };

  // CPU Heatmap
  this.processCpuHeatmapOption = {
    ...baseHeatmapOption,
    visualMap: {
      min: 0,
      max: 100,
      calculable: true,
      orient: 'horizontal',
      left: 'center',
      bottom: '5%',
      textStyle: {
        color: this.colors.fgText
      },
      inRange: {
        color: [
          '#f7fbff', '#deebf7', '#c6dbef', '#9ecae1', '#6baed6',
          '#4292c6', '#2171b5', '#08519c', '#08306b'
        ]
      }
    },
    series: [{
      name: 'CPU Usage',
      type: 'heatmap',
      data: cpuHeatmapData,
      emphasis: {
        itemStyle: {
          shadowBlur: 10,
          shadowColor: 'rgba(0, 0, 0, 0.5)'
        }
      }
    }]
  };

  // Memory Heatmap
  this.processMemHeatmapOption = {
    ...baseHeatmapOption,
    visualMap: {
      min: 0,
      max: 100,
      calculable: true,
      orient: 'horizontal',
      left: 'center',
      bottom: '5%',
      textStyle: {
        color: this.colors.fgText
      },
      inRange: {
        color: [
          '#fff7fb', '#ece7f2', '#d0d1e6', '#a6bddb', '#74a9cf',
          '#3690c0', '#0570b0', '#045a8d', '#023858'
        ]
      }
    },
    series: [{
      name: 'Memory Usage',
      type: 'heatmap',
      data: memHeatmapData,
      emphasis: {
        itemStyle: {
          shadowBlur: 10,
          shadowColor: 'rgba(0, 0, 0, 0.5)'
        }
      }
    }]
  };
}

// Add this interface to your component
interface ProcessStatistics {
  command: string;
  user: string;
  pid: number;
  totalCpu: number;
  totalMem: number;
  maxCpu: number;
  maxMem: number;
  count: number;
  avgCpu: number;
  avgMem: number;
  significance: number;
}

  /**
 * Generate process summary table data using aggregated fields
 */
  generateProcessSummary() {
    if (!this.historicalProcesses || this.historicalProcesses.length === 0) {
      this.processSummary = [];
      return;
    }

    // Group data by PID
    const dataByPid = new Map<number, AggregatedProcessData[]>();
    this.historicalProcesses.forEach(p => {
      if (!dataByPid.has(p.pid)) {
        dataByPid.set(p.pid, []);
      }
      dataByPid.get(p.pid).push(p);
    });

    // Create summary for each process using aggregated values
    this.processSummary = [];
    dataByPid.forEach((processData, pid) => {
      const process = processData[0];

      // Calculate weighted averages based on record count
      let totalCpu = 0;
      let totalMem = 0;
      let totalCount = 0;
      let maxCpu = 0;
      let maxMem = 0;

      processData.forEach(p => {
        totalCpu += p.avg_cpu * p.count;
        totalMem += p.avg_mem * p.count;
        totalCount += p.count;
        if (p.max_cpu > maxCpu) maxCpu = p.max_cpu;
        if (p.max_mem > maxMem) maxMem = p.max_mem;
      });

      const avgCpu = totalCount > 0 ? totalCpu / totalCount : 0;
      const avgMem = totalCount > 0 ? totalMem / totalCount : 0;

      this.processSummary.push({
        pid,
        command: process.command,
        user: process.user,
        count: totalCount,
        avgCpu: avgCpu.toFixed(2),
        maxCpu: maxCpu.toFixed(2),
        avgMem: avgMem.toFixed(2),
        maxMem: maxMem.toFixed(2),
      });
    });

    // Sort by highest average CPU
    this.processSummary.sort((a, b) => parseFloat(b.avgCpu) - parseFloat(a.avgCpu));
  }

  // Add helper methods
  private downsampleLTTB(data: [number, number][], threshold: number): [number, number][] {
    if (data.length <= threshold) return data;

    const sampled = [];
    const bucketSize = (data.length - 2) / (threshold - 2);
    let a = 0;

    sampled.push(data[a]);

    for (let i = 0; i < threshold - 2; i++) {
      const rangeStart = Math.floor((i + 1) * bucketSize) + 1;
      const rangeEnd = Math.min(Math.floor((i + 2) * bucketSize) + 1, data.length - 1);

      let maxArea = -1;
      let nextA = rangeStart;

      for (let j = rangeStart; j < rangeEnd; j++) {
        const area = Math.abs(
          (data[a][0] - data[data.length - 1][0]) * (data[j][1] - data[a][1]) -
          (data[a][0] - data[j][0]) * (data[data.length - 1][1] - data[a][1])
        ) / 2;

        if (area > maxArea) {
          maxArea = area;
          nextA = j;
        }
      }

      sampled.push(data[nextA]);
      a = nextA;
    }

    sampled.push(data[data.length - 1]);
    return sampled;
  }

  private adjustColorOpacity(color: string, opacity: number): string {
    if (color.startsWith('#')) {
      const r = parseInt(color.slice(1, 3), 16);
      const g = parseInt(color.slice(3, 5), 16);
      const b = parseInt(color.slice(5, 7), 16);
      return `rgba(${r}, ${g}, ${b}, ${opacity})`;
    }
    return color;
  }

  /**
   * Load historical data for all processes
   */
  loadHistoricalProcessData(): void {
    if (!this.validateForm()) return;

    this.loading = true;
    this.hasError = false;
    this.errorMessage = '';

    const range = this.getDateTimeRange();

    // Validate date range
    if (new Date(range.start) >= new Date(range.end)) {
      this.showError('End date must be after start date');
      this.loading = false;
      return;
    }

    console.log("Loading historical process data for range:", range);

    // Fetch historical data for all processes
    this.monitoringService.getHistoricalProcesses(range)
      .pipe(
        tap(response => {
          console.log("Historical data response:", response);
          this.historicalProcesses = response.data || [];

          if (this.historicalProcesses.length === 0) {
            this.showError(`No historical data found in the time range`);
          } else {
            console.log(`Loaded ${this.historicalProcesses.length} historical records`);
          }

          // Update charts
          this.updateProcessCharts();

          // Generate summary table
          this.generateProcessSummary();
        }),
        catchError(error => {
          console.error("Error fetching historical process data:", error);
          this.showError(`Failed to load historical data: ${error.message || 'Unknown error'}`);
          this.historicalProcesses = [];
          this.processSummary = [];
          return of(null);
        })
      )
      .subscribe(() => {
        this.loading = false;
      });
  }

  /**
   * Validate form and show appropriate error messages
   */
  private validateForm(): boolean {
    if (!this.filterForm.valid) {
      this.filterForm.markAllAsTouched();

      const errors: string[] = [];
      const controls = this.filterForm.controls;

      if (controls['startDate'].errors)
        errors.push('Please select a start date');
      if (controls['startTime'].errors)
        errors.push('Please select a start time');
      if (controls['endDate'].errors)
        errors.push('Please select an end date');
      if (controls['endTime'].errors)
        errors.push('Please select an end time');

      this.showError('Please fix the following errors: ' + errors.join(', '));
      return false;
    }
    return true;
  }

  /**
   * Show error message to user
   */
  private showError(message: string): void {
    this.hasError = true;
    this.errorMessage = message;
    console.error('Process Component Error:', message);
  }

  // Date/Time Helper Methods
  private formatDateForInput(date: Date): string {
    return date.toISOString().split("T")[0];
  }

  private getDateTimeRange(): DateTimeRange {
    const form = this.filterForm.value;
    const startDateTime = new Date(`${form.startDate}T${form.startTime}:00`);
    const endDateTime = new Date(`${form.endDate}T${form.endTime}:00`);

    return {
      start: startDateTime.toISOString(),
      end: endDateTime.toISOString(),
    };
  }

  // Quick Selection Methods
  selectToday(): void {
    const today = new Date();
    this.filterForm.patchValue({
      startDate: this.formatDateForInput(today),
      startTime: "00:00",
      endDate: this.formatDateForInput(today),
      endTime: "23:59",
    });
  }

  selectYesterday(): void {
    const yesterday = new Date();
    yesterday.setDate(yesterday.getDate() - 1);
    this.filterForm.patchValue({
      startDate: this.formatDateForInput(yesterday),
      startTime: "00:00",
      endDate: this.formatDateForInput(yesterday),
      endTime: "23:59",
    });
  }

  selectLast24Hours(): void { this.quickSelectRange(1); }
  selectLastWeek(): void { this.quickSelectRange(7); }
  selectLastMonth(): void { this.quickSelectRange(30); }

  private quickSelectRange(days: number): void {
    const now = new Date();
    const pastDate = new Date();
    pastDate.setDate(pastDate.getDate() - days);

    this.filterForm.patchValue({
      startDate: this.formatDateForInput(pastDate),
      startTime: "00:00",
      endDate: this.formatDateForInput(now),
      endTime: "23:59",
    });
  }

  // Process selection methods
  toggleProcessSelection(process: ProcessData): void {
    const index = this.selectedProcesses.findIndex(p => p.pid === process.pid);
    if (index !== -1) {
      this.selectedProcesses.splice(index, 1);
    } else {
      this.selectedProcesses.push(process);
    }
  }

  isProcessSelected(process: ProcessData): boolean {
    return this.selectedProcesses.some(p => p.pid === process.pid);
  }

  toggleAllProcesses(checked: boolean): void {
    if (checked) {
      this.selectedProcesses = [...this.activeProcesses];
    } else {
      this.selectedProcesses = [];
    }
  }

  selectProcess(process: ProcessData): void {
    // Add to selected processes if not already selected
    if (!this.selectedProcesses.some(p => p.pid === process.pid)) {
      this.selectedProcesses.push(process);
    }
  }

  // Utility Methods
  truncateCommand(command: string, maxLength: number): string {
    return command.length > maxLength
      ? command.substring(0, maxLength) + "..."
      : command;
  }

  getCpuStatusClass(value: number): string {
    if (value > 75) return "text-danger";
    if (value > 50) return "text-warning";
    return "text-success";
  }

  getMemStatusClass(value: number): string {
    if (value > 75) return "text-danger";
    if (value > 50) return "text-warning";
    return "text-success";
  }

  getCpuStatus(value: number): string {
    if (value > 75) return "danger";
    if (value > 50) return "warning";
    return "success";
  }

  getMemStatus(value: number): string {
    if (value > 75) return "danger";
    if (value > 50) return "warning";
    return "success";
  }
}